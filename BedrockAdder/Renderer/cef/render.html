<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>BA Render</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
    <script>
        (async function () {
            const url = new URL(window.location.href);
            const size = parseInt(url.searchParams.get('size') || '256', 10);
            const modelPath = url.searchParams.get('modelPath'); // file:///.../model.json
            const texMapB64 = url.searchParams.get('texMap');    // base64(JSON {slot->file:///...png})
            const bgTransparent = (url.searchParams.get('transparent') || '1') === '1';

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: bgTransparent });
            renderer.setPixelRatio(1);
            renderer.setSize(size, size);
            renderer.setClearAlpha(bgTransparent ? 0 : 1);
            document.body.appendChild(renderer.domElement);

            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.1);
            hemi.position.set(0, 50, 0);
            scene.add(hemi);

            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(30, 50, 40);
            scene.add(dir);

            function parseB64Json(b64) {
                try { return JSON.parse(atob(b64 || '')); } catch { return {}; }
            }

            function loadTexture(urlStr) {
                return new Promise((resolve) => {
                    const loader = new THREE.TextureLoader();
                    loader.load(urlStr, tex => {
                        tex.flipY = false;
                        resolve(tex);
                    }, undefined, () => resolve(null));
                });
            }

            async function loadTextureDictionary(map) {
                const result = {};
                const entries = Object.entries(map || {});
                for (const [slot, uri] of entries) {
                    if (!uri) continue;
                    result[slot] = await loadTexture(uri);
                }
                return result;
            }

            function boxGeomFromElement(el) {
                const f = el.from, t = el.to;
                const w = (t[0] - f[0]);
                const h = (t[1] - f[1]);
                const d = (t[2] - f[2]);
                const geom = new THREE.BoxGeometry(w, h, d);
                const cx = (f[0] + t[0]) / 2 - 8;
                const cy = 24 - (f[1] + t[1]) / 2;
                const cz = (f[2] + t[2]) / 2 - 8;
                geom.translate(cx, cy, cz);
                return geom;
            }

            function faceNameOrder() {
                return ["east", "west", "up", "down", "south", "north"];
            }

            function applyFaceUVs(geom, group, face, texture) {
                if (!geom || !group) return;
                const uvAttr = geom.attributes.uv;
                if (!uvAttr) return;

                const tex = texture || null;
                const texW = tex && tex.image && tex.image.width ? tex.image.width : 64;
                const texH = tex && tex.image && tex.image.height ? tex.image.height : 64;

                if (!face || !face.uv || face.uv.length < 4) return;

                const uv = face.uv;
                const u1 = Math.min(uv[0], uv[2]) / texW;
                const v1 = Math.min(uv[1], uv[3]) / texH;
                const u2 = Math.max(uv[0], uv[2]) / texW;
                const v2 = Math.max(uv[1], uv[3]) / texH;

                const start = group.start * 2; // each index has a matching uv pair
                const rect = [
                    u2, v1, u1, v1, u2, v2,
                    u1, v1, u1, v2, u2, v2
                ];

                for (let i = 0; i < rect.length && (start + i) < uvAttr.array.length; i++) {
                    uvAttr.array[start + i] = rect[i];
                }
                uvAttr.needsUpdate = true;
            }

            function sanitizeSlotName(slot) {
                if (typeof slot !== 'string') return '';
                return slot.startsWith('#') ? slot.substring(1) : slot;
            }

            function applyDisplayTransform(group, displayRoot) {
                if (!displayRoot) return;
                const gui = displayRoot.gui || displayRoot.GUI || null;
                if (!gui) return;

                const rot = Array.isArray(gui.rotation) ? gui.rotation : Array.isArray(gui.Rotation) ? gui.Rotation : null;
                const trans = Array.isArray(gui.translation) ? gui.translation : Array.isArray(gui.Translation) ? gui.Translation : null;
                const scale = Array.isArray(gui.scale) ? gui.scale : Array.isArray(gui.Scale) ? gui.Scale : null;

                if (rot && rot.length === 3) {
                    group.rotation.set(
                        THREE.MathUtils.degToRad(rot[0]),
                        THREE.MathUtils.degToRad(rot[1]),
                        THREE.MathUtils.degToRad(rot[2])
                    );
                }

                if (trans && trans.length === 3) {
                    group.position.set(trans[0] / 16, trans[1] / 16, trans[2] / 16);
                }

                if (scale && scale.length === 3) {
                    group.scale.set(scale[0], scale[1], scale[2]);
                }
            }

            try {
                const response = await fetch(modelPath);
                const model = await response.json();
                const texMap = parseB64Json(texMapB64);
                const textures = await loadTextureDictionary(texMap);
                const fallbackTexture = Object.values(textures).find(t => t) || null;

                const materialCache = new Map();
                const materials = [];

                function materialIndexFor(slotName) {
                    const slot = sanitizeSlotName(slotName);
                    const tex = (slot && textures[slot]) || fallbackTexture;
                    const key = tex ? tex.uuid : '__flat__';

                    if (!materialCache.has(key)) {
                        const mat = new THREE.MeshStandardMaterial({
                            map: tex || null,
                            transparent: true,
                            roughness: 0.8,
                            metalness: 0.0
                        });
                        materialCache.set(key, materials.length);
                        materials.push(mat);
                    }

                    return materialCache.get(key);
                }

                const rootGroup = new THREE.Group();
                const elements = model.elements || [];
                const order = faceNameOrder();

                elements.forEach(el => {
                    const geom = boxGeomFromElement(el);
                    const faces = el.faces || {};
                    const groups = geom.groups || [];

                    for (let g = 0; g < Math.min(groups.length, order.length); g++) {
                        const faceName = order[g];
                        const face = faces[faceName] || null;
                        const slotName = face && face.texture ? face.texture : null;
                        const matIndex = materialIndexFor(slotName);
                        if (groups[g]) {
                            groups[g].materialIndex = matIndex;
                        }
                        const slot = sanitizeSlotName(slotName);
                        const tex = (slot && textures[slot]) || fallbackTexture;
                        applyFaceUVs(geom, groups[g], face, tex);
                    }

                    const mesh = new THREE.Mesh(geom, materials);

                    if (el.rotation) {
                        const axis = el.rotation.axis || 'y';
                        const angle = (el.rotation.angle || 0) * Math.PI / 180;
                        if (axis === 'x') mesh.rotateX(angle);
                        else if (axis === 'y') mesh.rotateY(angle);
                        else if (axis === 'z') mesh.rotateZ(angle);
                    }

                    rootGroup.add(mesh);
                });

                const hadDisplay = !!(model.display && (model.display.gui || model.display.GUI));
                applyDisplayTransform(rootGroup, model.display);
                if (!hadDisplay) {
                    rootGroup.rotation.set(
                        THREE.MathUtils.degToRad(30),
                        THREE.MathUtils.degToRad(45),
                        0
                    );
                }
                scene.add(rootGroup);

                const bbox = new THREE.Box3().setFromObject(rootGroup);
                if (bbox.isEmpty()) {
                    camera.position.set(16, 16, 16);
                    camera.lookAt(0, 0, 0);
                } else {
                    const sizeVec = bbox.getSize(new THREE.Vector3());
                    const center = bbox.getCenter(new THREE.Vector3());

                    const maxDim = Math.max(sizeVec.x, sizeVec.y, sizeVec.z, 1);
                    const distance = maxDim * 1.9;
                    camera.position.set(center.x + distance, center.y + distance, center.z + distance);
                    camera.lookAt(center);
                }

                renderer.render(scene, camera);

                if (typeof renderer.dispose === 'function') {
                    renderer.dispose();
                }

                window.renderDone = true;
            } catch (e) {
                console.error(e);
                window.renderDone = true;
            }
        })();
    </script>
</body>
</html>