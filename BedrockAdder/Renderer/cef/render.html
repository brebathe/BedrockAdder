<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>BA Render</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden; /* prevent scrollbars from appearing in screenshots */
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Three.js from CDN (your working setup) -->
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
    <script>
        (async function () {
        const url = new URL(window.location.href);
        const size = parseInt(url.searchParams.get("size") || "256", 10);
        const modelPath = url.searchParams.get("modelPath"); // file:///.../model.json
        const texMapB64 = url.searchParams.get("texMap");    // base64(JSON {slot->file:///...png})
        const bgTransparent = (url.searchParams.get("transparent") || "1") === "1";

        const scene = new THREE.Scene();

        const frustumSize = 32;
        const aspect = 1;
        const camera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        0.1,
        1000
        );
        camera.position.set(0, 0, 48);
        camera.lookAt(0, 0, 0);

        // Fix global upside-down: flip camera 'up' direction
        camera.up.set(0, -1, 0);

        // Manual rotation adjustments in DEGREES (applied on top of display.gui.rotation)
        const adjX = 0;
        const adjY = 0;
        const adjZ = 0;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: bgTransparent });
        renderer.setPixelRatio(1);
        renderer.setSize(size, size);
        renderer.setClearAlpha(bgTransparent ? 0 : 1);
        document.body.appendChild(renderer.domElement);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(30, 50, 40);
        scene.add(dir);

        function parseB64Json(b64) {
        try { return JSON.parse(atob(b64 || "")); } catch { return {}; }
        }

        // Crop animated flipbook textures to the top frame
        function loadTexture(urlStr) {
        return new Promise((resolve) => {
        const loader = new THREE.TextureLoader();
        loader.load(
        urlStr,
        tex => {
        if (!tex) { resolve(null); return; }
        tex.flipY = false;

        try {
        const img = tex.image;
        if (img && img.width && img.height &&
        img.height > img.width &&
        (img.height % img.width) === 0) {

        const frameSize = img.width;
        const canvas = document.createElement("canvas");
        canvas.width = frameSize;
        canvas.height = frameSize;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(
        img,
        0, 0, frameSize, frameSize,
        0, 0, frameSize, frameSize
        );
        tex.image = canvas;
        tex.needsUpdate = true;
        }
        } catch (e) {
        // ignore and use original image
        }

        resolve(tex);
        },
        undefined,
        () => resolve(null)
        );
        });
        }

        async function loadTextureDictionary(map) {
        const result = {};
        const entries = Object.entries(map || {});
        for (const [slot, uri] of entries) {
        if (!uri) continue;
        const tex = await loadTexture(uri);
        if (tex) {
        result[slot] = tex;
        }
        }
        return result;
        }

        // Build box geometry for an element, plus its world-space center
        function boxGeomFromElement(el) {
        const f = el.from, t = el.to;
        const w = (t[0] - f[0]);
        const h = (t[1] - f[1]);
        const d = (t[2] - f[2]);

        // BoxGeometry centered at (0,0,0) in local space
        const geom = new THREE.BoxGeometry(w, h, d);

        // World-space center in Minecraft's 0..16 coordinates mapped to [-8, +8]
        const cx = (f[0] + t[0]) / 2 - 8;
        const cy = (f[1] + t[1]) / 2 - 8;
        const cz = (f[2] + t[2]) / 2 - 8;

        return { geom, cx, cy, cz };
        }

        function faceNameOrder() {
        return ["east", "west", "up", "down", "south", "north"];
        }

        // Flag to distinguish atlas-based models (3D items) vs cuboid blocks
        let modelHasTextureAtlas = false;

        // ---------------------------------------------------------
        // NEW: map Minecraft face name -> BoxGeometry face index
        // BoxGeometry builds faces in this order: +X, -X, +Y, -Y, +Z, -Z
        // We map that to east, west, up, down, south, north.
        // ---------------------------------------------------------
        const FACE_INDEX_BY_NAME = {
        east: 0,   // +X
        west: 1,   // -X
        up:   2,   // +Y
        down: 3,   // -Y
        south:4,   // +Z
        north:5    // -Z
        };

        // Apply UVs / flips:
        // - For atlas models: use face.uv to overwrite the box face rect.
        // - For non-atlas cuboids: rely on BoxGeometry defaults, only flip V on side faces.
        function applyFaceUVs(geom, group, face, texture, faceName) {
        if (!geom) return;
        const uvAttr = geom.attributes.uv;
        if (!uvAttr) return;

        // Which face of the box are we addressing?
        const faceIndex = FACE_INDEX_BY_NAME[faceName];
        if (faceIndex === undefined) return;

        const vertsPerFace = 4;
        const compsPerVert = 2;
        const base = faceIndex * vertsPerFace * compsPerVert; // 0,8,16,...

        // --- Non-atlas case: just flip existing V for side faces ---
        if (!modelHasTextureAtlas) {
        if (faceName === "north" || faceName === "south" ||
        faceName === "east"  || faceName === "west") {

        for (let v = 0; v < vertsPerFace; v++) {
        const vIndex = base + v * compsPerVert + 1; // +1 = V component
        if (vIndex < uvAttr.array.length) {
        uvAttr.array[vIndex] = 1.0 - uvAttr.array[vIndex];
        }
        }
        uvAttr.needsUpdate = true;
        }
        return;
        }

        // --- Atlas-based (or explicit UV-based) case ---
        if (!face || !face.uv || face.uv.length < 4) return;

        const tex = texture || null;
        const texW = tex && tex.image && tex.image.width  ? tex.image.width  : 16;
        const texH = tex && tex.image && tex.image.height ? tex.image.height : 16;

        const uv = face.uv;
        let u1 = uv[0] / texW;
        let v1 = uv[1] / texH;
        let u2 = uv[2] / texW;
        let v2 = uv[3] / texH;

        // If you later need a V-flip for side faces, you can re-enable this:
        // if (faceName === "north" || faceName === "south" ||
        //     faceName === "east"  || faceName === "west") {
        //     const tmp = v1;
        //     v1 = v2;
        //     v2 = tmp;
        // }

        // 4 vertices per face; BoxGeometry uses 4 distinct verts per face.
        const uvs = [
        u1, v1,  // v0
        u2, v1,  // v1
        u1, v2,  // v2
        u2, v2   // v3
        ];

        for (let i = 0; i < uvs.length; i++) {
        const idx = base + i;
        if (idx < uvAttr.array.length) {
        uvAttr.array[idx] = uvs[i];
        }
        }

        uvAttr.needsUpdate = true;
        }

        function sanitizeSlotName(slot) {
        if (typeof slot !== "string") return "";
        return slot.startsWith("#") ? slot.substring(1) : slot;
        }

        // Apply ONLY the display.gui transform from the model.
        function applyDisplayTransform(group, displayRoot) {
        if (!displayRoot) return;
        const gui = displayRoot.gui || displayRoot.GUI || null;
        if (!gui) return;

        const rot = Array.isArray(gui.rotation) ? gui.rotation :
        Array.isArray(gui.Rotation) ? gui.Rotation : null;
        const trans = Array.isArray(gui.translation) ? gui.translation :
        Array.isArray(gui.Translation) ? gui.Translation : null;
        const scale = Array.isArray(gui.scale) ? gui.scale :
        Array.isArray(gui.Scale) ? gui.Scale : null;

        if (rot && rot.length === 3) {
        group.rotation.set(
        THREE.MathUtils.degToRad(rot[0]),
        THREE.MathUtils.degToRad(rot[1]),
        THREE.MathUtils.degToRad(rot[2])
        );
        } else {
        group.rotation.set(
        THREE.MathUtils.degToRad(adjX),
        THREE.MathUtils.degToRad(adjY),
        THREE.MathUtils.degToRad(adjZ)
        );
        }

        if (trans && trans.length === 3) {
        group.position.set(trans[0] / 16, trans[1] / 16, trans[2] / 16);
        }

        if (scale && scale.length === 3) {
        group.scale.set(scale[0], scale[1], scale[2]);
        }
        }

        try {
        const response = await fetch(modelPath);
        const model = await response.json();

        // Detect atlas-based vs plain cuboid
        modelHasTextureAtlas = !!(model.textures && Object.keys(model.textures).length > 0);

        const texMap = parseB64Json(texMapB64);
        const textures = await loadTextureDictionary(texMap);
        const fallbackTexture = Object.values(textures).find(t => t) || null;

        const materialCache = new Map();
        const materials = [];

        function materialIndexFor(slotName) {
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        const key = tex ? tex.uuid : "__flat__";

        if (!materialCache.has(key)) {
        const mat = new THREE.MeshStandardMaterial({
        map: tex || null,
        transparent: true,
        roughness: 0.8,
        metalness: 0.0
        });
        materialCache.set(key, materials.length);
        materials.push(mat);
        }

        return materialCache.get(key);
        }

        const rootGroup = new THREE.Group();
        const elements = model.elements || [];
        const order = faceNameOrder();

        elements.forEach(el => {
        const { geom, cx, cy, cz } = boxGeomFromElement(el);
        const faces = el.faces || {};
        const groups = geom.groups || [];

        // Assign materials + UVs per face
        for (let g = 0; g < Math.min(groups.length, order.length); g++) {
        const faceName = order[g];
        const face = faces[faceName] || null;
        const slotName = face && face.texture ? face.texture : null;
        const matIndex = materialIndexFor(slotName);
        if (groups[g]) {
        groups[g].materialIndex = matIndex;
        }
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        applyFaceUVs(geom, groups[g], face, tex, faceName);
        }

        const mesh = new THREE.Mesh(geom, materials);

        // Build a pivot object so we can rotate around el.rotation.origin
        const pivotObj = new THREE.Object3D();

        if (el.rotation && typeof el.rotation === "object") {
        const axis = el.rotation.axis || "y";
        const angleDeg = el.rotation.angle || 0;
        const angleRad = THREE.MathUtils.degToRad(angleDeg);

        const origin = Array.isArray(el.rotation.origin)
        ? el.rotation.origin
        : [8, 8, 8];

        // Convert origin from 0..16 block coords to [-8, +8] world coords
        const px = origin[0] - 8;
        const py = origin[1] - 8;
        const pz = origin[2] - 8;

        // Pivot at world origin 'origin', mesh relative to that pivot
        pivotObj.position.set(px, py, pz);
        mesh.position.set(cx - px, cy - py, cz - pz);

        if (angleRad !== 0) {
        if (axis === "x") pivotObj.rotateX(angleRad);
        else if (axis === "y") pivotObj.rotateY(angleRad);
        else if (axis === "z") pivotObj.rotateZ(angleRad);
        }
        } else {
        // No rotation: just place mesh at its world-space center
        pivotObj.position.set(cx, cy, cz);
        mesh.position.set(0, 0, 0);
        }

        pivotObj.add(mesh);
        rootGroup.add(pivotObj);
        });

        applyDisplayTransform(rootGroup, model.display);
        scene.add(rootGroup);

        renderer.render(scene, camera);

        if (typeof renderer.dispose === "function") {
        renderer.dispose();
        }

        window.renderDone = true;
        } catch (e) {
        console.error(e);
        window.renderDone = true;
        }
        })();
    </script>
</body>
</html>