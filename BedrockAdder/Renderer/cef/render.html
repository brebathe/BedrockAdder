<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>BA Render</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden; /* prevent scrollbars from appearing in screenshots */
        }

        canvas {
            display: block;
        }
    </style>
    <!-- Three.js from CDN (your working setup) -->
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
    <script>
        (async function () {
        const url = new URL(window.location.href);
        const size = parseInt(url.searchParams.get("size") || "256", 10);
        const modelPath = url.searchParams.get("modelPath"); // file:///.../model.json
        const texMapB64 = url.searchParams.get("texMap");    // base64(JSON {slot->file:///...png})
        const bgTransparent = (url.searchParams.get("transparent") || "1") === "1";

        const scene = new THREE.Scene();

        const frustumSize = 32;
        const aspect = 1;
        const camera = new THREE.OrthographicCamera(
        -frustumSize * aspect / 2,
        frustumSize * aspect / 2,
        frustumSize / 2,
        -frustumSize / 2,
        0.1,
        1000
        );
        camera.position.set(0, 0, 48);
        camera.lookAt(0, 0, 0);

        // Fix global upside-down: flip camera 'up' direction
        camera.up.set(0, -1, 0);

        // Manual rotation adjustments in DEGREES (applied on top of display.gui.rotation)
        const adjX = 0;
        const adjY = 0;
        const adjZ = 0;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: bgTransparent });
        renderer.setPixelRatio(1);
        renderer.setSize(size, size);
        renderer.setClearAlpha(bgTransparent ? 0 : 1);
        document.body.appendChild(renderer.domElement);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(30, 50, 40);
        scene.add(dir);

        function parseB64Json(b64) {
        try { return JSON.parse(atob(b64 || "")); } catch { return {}; }
        }

        // Crop animated flipbook textures to the top frame
        function loadTexture(urlStr) {
        return new Promise((resolve) => {
        const loader = new THREE.TextureLoader();
        loader.load(
        urlStr,
        tex => {
        if (!tex) { resolve(null); return; }
        tex.flipY = false;

        try {
        const img = tex.image;
        if (img && img.width && img.height &&
        img.height > img.width &&
        (img.height % img.width) === 0) {

        const frameSize = img.width;
        const canvas = document.createElement("canvas");
        canvas.width = frameSize;
        canvas.height = frameSize;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(
        img,
        0, 0, frameSize, frameSize,
        0, 0, frameSize, frameSize
        );
        tex.image = canvas;
        tex.needsUpdate = true;
        }
        } catch (e) {
        // ignore and use original image
        }

        resolve(tex);
        },
        undefined,
        () => resolve(null)
        );
        });
        }

        async function loadTextureDictionary(map) {
        const result = {};
        const entries = Object.entries(map || {});
        for (const [slot, uri] of entries) {
        if (!uri) continue;
        const tex = await loadTexture(uri);
        if (tex) {
        result[slot] = tex;
        }
        }
        return result;
        }

        function boxGeomFromElement(el) {
        const f = el.from, t = el.to;
        const w = (t[0] - f[0]);
        const h = (t[1] - f[1]);
        const d = (t[2] - f[2]);
        const geom = new THREE.BoxGeometry(w, h, d);

        // Center the element in [-8, +8] on all axes (MC-style)
        const cx = (f[0] + t[0]) / 2 - 8;
        const cy = (f[1] + t[1]) / 2 - 8;
        const cz = (f[2] + t[2]) / 2 - 8;
        geom.translate(cx, cy, cz);
        return geom;
        }

        function faceNameOrder() {
        return ["east", "west", "up", "down", "south", "north"];
        }

        // Flag to distinguish atlas-based models (3D items) vs cuboid blocks
        let modelHasTextureAtlas = false;

        // Apply UVs / flips:
        // - For atlas models: use face.uv, and flip V on side faces.
        // - For non-atlas cuboids: rely on BoxGeometry defaults, with a simple V-flip on side faces.
        function applyFaceUVs(geom, group, face, texture, faceName) {
        if (!geom || !group) return;
        const uvAttr = geom.attributes.uv;
        if (!uvAttr) return;

        // Non-atlas case: flip existing V for side faces only
        if (!modelHasTextureAtlas) {
        if (faceName === "north" || faceName === "south" || faceName === "east" || faceName === "west") {
        const start = group.start * 2;
        // 6 vertices per face, 2 components per vertex → 12 floats
        for (let i = 0; i < 6; i++) {
        const vIndex = start + i * 2 + 1; // +1 = V component
        if (vIndex < uvAttr.array.length) {
        uvAttr.array[vIndex] = 1.0 - uvAttr.array[vIndex];
        }
        }
        uvAttr.needsUpdate = true;
        }
        return;
        }

        // Atlas-based model (3D item / example cuboid using atlas)
        if (!face || !face.uv || face.uv.length < 4) return;

        const tex = texture || null;
        const texW = tex && tex.image && tex.image.width ? tex.image.width : 16;
        const texH = tex && tex.image && tex.image.height ? tex.image.height : 16;

        const uv = face.uv;
        let u1 = uv[0] / texW;
        let v1 = uv[1] / texH;
        let u2 = uv[2] / texW;
        let v2 = uv[3] / texH;

        // Flip V on side faces
        if (faceName === "north" || faceName === "south" || faceName === "east" || faceName === "west") {
        const tmp = v1;
        v1 = v2;
        v2 = tmp;
        }

        const start = group.start * 2;
        const rect = [
        // first triangle
        u2, v1,
        u1, v1,
        u2, v2,
        // second triangle
        u1, v1,
        u1, v2,
        u2, v2
        ];

        for (let i = 0; i < rect.length && (start + i) < uvAttr.array.length; i++) {
        uvAttr.array[start + i] = rect[i];
        }

        uvAttr.needsUpdate = true;
        }

        function sanitizeSlotName(slot) {
        if (typeof slot !== "string") return "";
        return slot.startsWith("#") ? slot.substring(1) : slot;
        }

        // Apply ONLY the display.gui transform from the model.
        function applyDisplayTransform(group, displayRoot) {
        if (!displayRoot) return;
        const gui = displayRoot.gui || displayRoot.GUI || null;
        if (!gui) return;

        const rot = Array.isArray(gui.rotation) ? gui.rotation :
        Array.isArray(gui.Rotation) ? gui.Rotation : null;
        const trans = Array.isArray(gui.translation) ? gui.translation :
        Array.isArray(gui.Translation) ? gui.Translation : null;
        const scale = Array.isArray(gui.scale) ? gui.scale :
        Array.isArray(gui.Scale) ? gui.Scale : null;

        if (rot && rot.length === 3) {
        group.rotation.set(
        THREE.MathUtils.degToRad(rot[0]),
        THREE.MathUtils.degToRad(rot[1]),
        THREE.MathUtils.degToRad(rot[2])
        );
        } else {
        group.rotation.set(
        THREE.MathUtils.degToRad(adjX),
        THREE.MathUtils.degToRad(adjY),
        THREE.MathUtils.degToRad(adjZ)
        );
        }

        if (trans && trans.length === 3) {
        group.position.set(trans[0] / 16, trans[1] / 16, trans[2] / 16);
        }

        if (scale && scale.length === 3) {
        group.scale.set(scale[0], scale[1], scale[2]);
        }
        }

        try {
        const response = await fetch(modelPath);
        const model = await response.json();

        // Detect atlas-based vs plain cuboid
        modelHasTextureAtlas = !!(model.textures && Object.keys(model.textures).length > 0);

        const texMap = parseB64Json(texMapB64);
        const textures = await loadTextureDictionary(texMap);
        const fallbackTexture = Object.values(textures).find(t => t) || null;

        const materialCache = new Map();
        const materials = [];

        function materialIndexFor(slotName) {
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        const key = tex ? tex.uuid : "__flat__";

        if (!materialCache.has(key)) {
        const mat = new THREE.MeshStandardMaterial({
        map: tex || null,
        transparent: true,
        roughness: 0.8,
        metalness: 0.0
        });
        materialCache.set(key, materials.length);
        materials.push(mat);
        }

        return materialCache.get(key);
        }

        const rootGroup = new THREE.Group();
        const elements = model.elements || [];
        const order = faceNameOrder();

        elements.forEach(el => {
        const geom = boxGeomFromElement(el);
        const faces = el.faces || {};
        const groups = geom.groups || [];

        for (let g = 0; g < Math.min(groups.length, order.length); g++) {
        const faceName = order[g];
        const face = faces[faceName] || null;
        const slotName = face && face.texture ? face.texture : null;
        const matIndex = materialIndexFor(slotName);
        if (groups[g]) {
        groups[g].materialIndex = matIndex;
        }
        const slot = sanitizeSlotName(slotName);
        const tex = (slot && textures[slot]) || fallbackTexture;
        applyFaceUVs(geom, groups[g], face, tex, faceName);
        }

        const mesh = new THREE.Mesh(geom, materials);

        if (el.rotation) {
        const axis = el.rotation.axis || "y";
        const angle = (el.rotation.angle || 0) * Math.PI / 180;
        if (axis === "x") mesh.rotateX(angle);
        else if (axis === "y") mesh.rotateY(angle);
        else if (axis === "z") mesh.rotateZ(angle);
        }

        rootGroup.add(mesh);
        });

        applyDisplayTransform(rootGroup, model.display);
        scene.add(rootGroup);

        renderer.render(scene, camera);

        if (typeof renderer.dispose === "function") {
        renderer.dispose();
        }

        window.renderDone = true;
        } catch (e) {
        console.error(e);
        window.renderDone = true;
        }
        })();
    </script>
</body>
</html>