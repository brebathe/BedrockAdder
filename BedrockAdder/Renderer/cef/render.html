<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>BA Render</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
    <script>
        (async function() {
        const url = new URL(window.location.href);
        const size = parseInt(url.searchParams.get('size') || '256', 10);
        const modelPath = url.searchParams.get('modelPath'); // file:///.../model.json
        const texMapB64 = url.searchParams.get('texMap');    // base64(JSON {slot->file:///...png})
        const bgTransparent = (url.searchParams.get('transparent') || '1') === '1';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 1000);
        camera.position.set(24, 24, 36);
        camera.lookAt(0, 12, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: bgTransparent });
        renderer.setSize(size, size);
        document.body.appendChild(renderer.domElement);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.1);
        hemi.position.set(0, 50, 0);
        scene.add(hemi);

        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(30, 50, 40);
        scene.add(dir);

        function parseB64Json(b64) {
        try { return JSON.parse(atob(b64 || '')); } catch { return {}; }
        }

        function fileTexture(urlStr) {
        return new Promise((resolve) => {
        const tl = new THREE.TextureLoader();
        tl.load(urlStr, tex => { tex.flipY = false; resolve(tex); }, undefined, () => resolve(null));
        });
        }

        function boxGeomFromElement(el) {
        const f = el.from, t = el.to;
        const w = (t[0] - f[0]);
        const h = (t[1] - f[1]);
        const d = (t[2] - f[2]);
        const geom = new THREE.BoxGeometry(w, h, d);
        // translate: center at ((f+t)/2) then shift to our world (Java→Bedrock-ish)
        const cx = (f[0] + t[0]) / 2 - 8;
        const cy = 24 - (f[1] + t[1]) / 2;
        const cz = (f[2] + t[2]) / 2 - 8;
        geom.translate(cx, cy, cz);
        return geom;
        }

        function applyFaceUVs(geom, el, mainTex) {
        // Minimal UV mapping: use per-face UV rects if present, normalized by texture size.
        // three.js BoxGeometry index order: px nx py ny pz nz (groups 0..5)
        const faces = el.faces || {};
        const groups = geom.groups || [];
        const uvAttr = geom.attributes.uv;
        const texW = mainTex ? mainTex.image.width : 64;
        const texH = mainTex ? mainTex.image.height : 64;

        const mapNames = ["east","west","up","down","south","north"]; // match to groups 0..5
        for (let g = 0; g < Math.min(groups.length, 6); g++) {
        const faceName = mapNames[g];
        const face = faces[faceName];
        if (!face || !face.uv) continue;
        const uv = face.uv; // [u1,v1,u2,v2]
        const u1 = Math.min(uv[0], uv[2]) / texW;
        const v1 = Math.min(uv[1], uv[3]) / texH;
        const u2 = Math.max(uv[0], uv[2]) / texW;
        const v2 = Math.max(uv[1], uv[3]) / texH;

        // Each group has 2 triangles (6 uv coords => 12 numbers). Update the slice.
        const start = groups[g].start * 2; // 2 uv per vertex
        const rect = [
        u2, v1,  u1, v1,  u2, v2,  // tri 1
        u1, v1,  u1, v2,  u2, v2   // tri 2
        ];
        for (let i = 0; i < 12; i++) {
        uvAttr.array[start + i] = rect[i];
        }
        }
        uvAttr.needsUpdate = true;
        }

        try {
        const model = await (await fetch(modelPath)).json();
        const texMap = parseB64Json(texMapB64);
        // choose a "main" texture (used only for uv normalization); first available wins
        let mainTex = null;
        for (const k of Object.keys(texMap)) {
        mainTex = await fileTexture(texMap[k]);
        if (mainTex) break;
        }
        const mat = new THREE.MeshStandardMaterial({
        map: mainTex,
        transparent: true
        });

        const elements = model.elements || [];
        elements.forEach(el => {
        const geom = boxGeomFromElement(el);
        if (mainTex) applyFaceUVs(geom, el, mainTex);
        const mesh = new THREE.Mesh(geom, mat);
        // single-axis element rotation (Blockbench-style)
        if (el.rotation) {
        const axis = el.rotation.axis || "y";
        const angle = (el.rotation.angle || 0) * Math.PI / 180;
        if (axis === "x") mesh.rotateX(angle);
        else if (axis === "y") mesh.rotateY(angle);
        else if (axis === "z") mesh.rotateZ(angle);
        }
        scene.add(mesh);
        });

        renderer.render(scene, camera);
        window.renderDone = true;
        } catch (e) {
        console.error(e);
        window.renderDone = true;
        }
        })();
    </script>
</body>
</html>